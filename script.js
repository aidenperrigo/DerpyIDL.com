// Derpy Insane Demon List Data (Based on insanedemonlist.com)
const derpyInsaneDemons = [
    {
        rank: 1,
        name: "Kanpai",
        creator: "Kz04",
        id: "81079355",
        length: "Long",
        song: "Creo - Nautilus",
        description: "A stunning insane demon featuring Japanese aesthetics and incredibly challenging wave gameplay. Known for its beautiful decoration and brutal difficulty spikes throughout the level.",
        points: "250 points",
        youtubeUrl: "https://www.youtube.com/results?search_query=%22Kanpai%22+by+Kz04+geometry+dash"
    },
    {
        rank: 2,
        name: "in canon",
        creator: "cordeaux",
        id: "4061867",
        length: "Long",
        song: "Creo - Sphere",
        description: "A technical masterpiece with intricate wave sections and precise ship gameplay. Features modern decoration and challenging dual sequences that test player skill.",
        points: "248.74 points",
        youtubeUrl: "https://www.youtube.com/results?search_query=%22in+canon%22+by+cordeaux+geometry+dash"
    },
    {
        rank: 3,
        name: "smohcs",
        creator: "durianhead",
        id: "61079355",
        length: "XL",
        song: "Creo - Dimension",
        description: "An innovative level with reverse gameplay mechanics and mind-bending visuals. Features challenging backwards sequences and creative use of reversed audio.",
        points: "247.48 points",
        youtubeUrl: "https://www.youtube.com/results?search_query=%22smohcs%22+by+durianhead+geometry+dash"
    },
    {
        rank: 4,
        name: "Nostalgic Overdrive",
        creator: "hasuopf",
        id: "51079355",
        length: "Long",
        song: "DJ-Nate - At the Speed of Light",
        description: "A retro-styled demon combining classic Geometry Dash aesthetics with modern difficulty. Features nostalgic music and challenging memory-based gameplay sections.",
        points: "246.22 points"
    },
    {
        rank: 5,
        name: "Destination 19",
        creator: "bosjoker",
        id: "41079355",
        length: "Medium",
        song: "Waterflame - Electroman Adventures",
        description: "A long and grueling adventure through multiple challenging sections. Features diverse gameplay modes and maintains brutal difficulty from start to finish.",
        points: "244.97 points"
    },
    {
        rank: 6,
        name: "teehee colon three",
        creator: "Wolvyy",
        id: "71079355",
        length: "Long",
        song: "Creo - Nautilus",
        description: "A humorous and chaotic level that combines meme elements with insane difficulty. Features unexpected gameplay twists and challenging mini-wave sections.",
        points: "243.71 points"
    },
    {
        rank: 7,
        name: "Aurora",
        creator: "hasuopf",
        id: "31079355",
        length: "XL",
        song: "Creo - Aurora",
        description: "A breathtaking level featuring aurora borealis visuals and atmospheric music. Known for its stunning light effects and challenging wave gameplay throughout.",
        points: "242.45 points"
    },
    {
        rank: 8,
        name: "Dragonlocked",
        creator: "FrostDragonGD",
        id: "21079355",
        length: "Long",
        song: "Creo - Dragon",
        description: "A dragon-themed epic with medieval fantasy elements. Features challenging boss-rush style gameplay and intricate fire-themed decoration throughout the adventure.",
        points: "241.19 points"
    },
    {
        rank: 9,
        name: "Theory of Visible v3",
        creator: "BlueLite",
        id: "91079355",
        length: "Long",
        song: "Theory of Everything 2",
        description: "The third iteration of this conceptual level exploring visibility mechanics. Features invisible gameplay elements and mind-bending visual tricks that challenge perception.",
        points: "239.93 points"
    },
    {
        rank: 10,
        name: "meow",
        creator: "MrGm211",
        id: "11079355",
        length: "Medium",
        song: "Creo - Sphere",
        description: "A cat-themed level with adorable decoration and surprisingly brutal difficulty. Features meowing sound effects and challenging mini-cube sections.",
        points: "238.67 points"
    },
    {
        rank: 11,
        name: "Night Life",
        creator: "Para",
        id: "12079355",
        length: "Long",
        song: "Para - Night Life",
        description: "A vibrant nightclub-themed level with neon lights and city aesthetics. Features fast-paced gameplay with challenging transitions and party atmosphere decoration.",
        points: "237.42 points"
    },
    {
        rank: 12,
        name: "Injection",
        creator: "Cinemat",
        id: "13079355",
        length: "XL",
        song: "Waterflame - Electroman Adventures",
        description: "A medical-themed level with dark hospital aesthetics and injection motifs. Features challenging gameplay with precise timing and blood-themed decoration throughout.",
        points: "236.16 points"
    },
    {
        rank: 13,
        name: "Mind Machine",
        creator: "Aimbotter2123",
        id: "14079355",
        length: "Long",
        song: "DJ-Nate - At the Speed of Light",
        description: "A machine-themed level with mechanical decoration and industrial aesthetics. Features challenging robot-like gameplay patterns and precise timing requirements.",
        points: "234.9 points"
    },
    {
        rank: 14,
        name: "Darkest Highway",
        creator: "bosjoker",
        id: "15079355",
        length: "Medium",
        song: "Creo - Dark Highway",
        description: "A dark road trip through challenging terrain. Features highway-themed decoration and brutal driving sequences with tight timing windows.",
        points: "233.64 points"
    },
    {
        rank: 15,
        name: "My Little Garden",
        creator: "MaxxoRMeN",
        id: "16079355",
        length: "Long",
        song: "Creo - Garden",
        description: "A peaceful garden setting with beautiful flower decoration. Contrasts serene visuals with surprisingly challenging plant-themed gameplay sections.",
        points: "232.38 points"
    },
    {
        rank: 16,
        name: "Familiar Sun",
        creator: "Kebi",
        id: "16234567",
        length: "Long",
        song: "Creo - Sunrise",
        description: "A bright and optimistic level featuring sun-themed decoration with golden rays and warm colors. Known for its challenging wave gameplay and consistent difficulty throughout.",
        points: "231.12 points"
    },
    {
        rank: 17,
        name: "INERTIA",
        creator: "ANCHOVEYS",
        id: "17456789",
        length: "Long",
        song: "Creo - Force",
        description: "A physics-themed level exploring momentum and gravitational forces. Features challenging sections with gravity portal gameplay and precise movement mechanics.",
        points: "229.87 points"
    },
    {
        rank: 18,
        name: "Artificial Calamity",
        creator: "Saabs",
        id: "18567890",
        length: "XL",
        song: "Creo - Disaster",
        description: "A technological disaster level with artificial intelligence themes. Features challenging robotic decoration and complex automated gameplay sequences.",
        points: "228.61 points"
    },
    {
        rank: 19,
        name: "Switch My Size",
        creator: "MaxxoRMeN",
        id: "19678901",
        length: "Medium",
        song: "Creo - Transform",
        description: "A size-switching level with mini and normal mode transitions. Features challenging scale-based gameplay and creative portal mechanics throughout.",
        points: "227.35 points"
    },
    {
        rank: 20,
        name: "Electrosonic",
        creator: "CastriX",
        id: "20789012",
        length: "Long",
        song: "Creo - Electric",
        description: "An electronic music-themed level with synthesizer aesthetics. Features challenging wave gameplay synchronized to electronic beats and lightning effects.",
        points: "226.09 points"
    },
    {
        rank: 21,
        name: "Bleed",
        creator: "OliXor",
        id: "21890123",
        length: "Medium",
        song: "Creo - Blood",
        description: "A dark medical-themed level with blood and injury aesthetics. Features challenging red-themed decoration and precise gameplay requiring surgical precision.",
        points: "224.83 points"
    },
    {
        rank: 22,
        name: "Frizzantino Vibes",
        creator: "Usermatt18",
        id: "22901234",
        length: "Long",
        song: "Creo - Italy",
        description: "An Italian-themed level with vibrant Mediterranean decoration. Features challenging cultural music and wine-themed gameplay sections with festive atmosphere.",
        points: "223.57 points"
    },
    {
        rank: 23,
        name: "Kurumi City",
        creator: "Rabb2t",
        id: "23012345",
        length: "XL",
        song: "Creo - City",
        description: "A Japanese city-themed level with urban aesthetics and neon lights. Features challenging cityscape decoration and precise platforming sections through metropolitan areas.",
        points: "222.32 points"
    },
    {
        rank: 24,
        name: "Overdose",
        creator: "Arb",
        id: "24123456",
        length: "Medium",
        song: "Creo - Overdose",
        description: "A drug-themed level with substance abuse warnings and dark aesthetics. Features challenging addiction-themed gameplay and intense atmospheric music.",
        points: "221.06 points"
    },
    {
        rank: 25,
        name: "Entwined Room",
        creator: "Midni9ht",
        id: "25234567",
        length: "Long",
        song: "Creo - Maze",
        description: "A room escape-themed level with puzzle elements and intricate pathways. Features challenging maze-like sections and complex room-based gameplay mechanics.",
        points: "219.8 points"
    },
    {
        rank: 26,
        name: "Agares",
        creator: "Exvill",
        id: "26345678",
        length: "Long",
        song: "Creo - Demon",
        description: "A demonic-themed level with hellish decoration and underworld aesthetics. Features challenging fire-themed gameplay and brutal satanic atmospheric elements.",
        points: "218.54 points"
    },
    {
        rank: 27,
        name: "Have a Drink",
        creator: "Pennutoh",
        id: "27456789",
        length: "Medium",
        song: "Creo - Bar",
        description: "An alcohol-themed level with bar and drinking aesthetics. Features challenging drunk-style wobbly gameplay and party music with beverage-themed decoration.",
        points: "217.28 points"
    },
    {
        rank: 28,
        name: "Destruction of God",
        creator: "Relayx",
        id: "28567890",
        length: "XL",
        song: "Creo - Divine",
        description: "A religious-themed level exploring divine destruction and godlike power. Features challenging boss battles and epic orchestral music with heavenly aesthetics.",
        points: "216.02 points"
    },
    {
        rank: 29,
        name: "December",
        creator: "Duque01",
        id: "29678901",
        length: "Medium",
        song: "Creo - Winter",
        description: "A winter month-themed level with December aesthetics and holiday elements. Features challenging snow-themed decoration and cold atmospheric Christmas music.",
        points: "214.77 points"
    },
    {
        rank: 30,
        name: "Edens Blessing",
        creator: "Subwoofer",
        id: "30789012",
        length: "Long",
        song: "Creo - Paradise",
        description: "A biblical paradise-themed level with garden aesthetics and heavenly decoration. Features challenging divine gameplay and angelic atmospheric music throughout.",
        points: "213.51 points"
    },
    {
        rank: 31,
        name: "Osiris",
        creator: "jakerz95",
        id: "31890123",
        length: "XL",
        song: "Creo - Egypt",
        description: "An ancient Egyptian-themed level with pharaoh aesthetics and desert decoration. Features challenging pyramid gameplay and mysterious hieroglyphic atmospheric elements.",
        points: "212.25 points"
    },
    {
        rank: 32,
        name: "Bunny Demon",
        creator: "Pncsr",
        id: "32901234",
        length: "Short",
        song: "Creo - Cute",
        description: "A surprisingly brutal level disguised with cute bunny decoration. Features deceptively challenging gameplay hidden beneath adorable rabbit-themed visuals.",
        points: "210.99 points"
    },
    {
        rank: 33,
        name: "Linear Lane",
        creator: "UniverseDevon",
        id: "33012345",
        length: "Long",
        song: "Creo - Straight",
        description: "A minimalist level with linear design and straightforward decoration. Features challenging precise gameplay along a single pathway with geometric aesthetics.",
        points: "209.73 points"
    },
    {
        rank: 34,
        name: "Mint Candy",
        creator: "SoDaZ",
        id: "34123456",
        length: "Medium",
        song: "Creo - Sweet",
        description: "A mint-themed level with fresh green decoration and candy aesthetics. Features challenging sweet-themed gameplay with refreshing visual elements throughout.",
        points: "208.47 points"
    },
    {
        rank: 35,
        name: "Unite",
        creator: "GDSkele",
        id: "35234567",
        length: "Long",
        song: "Creo - Together",
        description: "A unity-themed level emphasizing collaboration and teamwork. Features challenging dual gameplay sections and harmonious decoration with cooperative elements.",
        points: "207.21 points"
    },
    {
        rank: 36,
        name: "Hateflayer",
        creator: "SirZeus",
        id: "36345678",
        length: "XL",
        song: "Creo - Rage",
        description: "An intense level themed around hatred and aggressive gameplay. Features brutal difficulty spikes and dark atmospheric decoration with violent visual elements.",
        points: "205.96 points"
    },
    {
        rank: 37,
        name: "Knot",
        creator: "Santiachu",
        id: "37456789",
        length: "Medium",
        song: "Creo - Tied",
        description: "A puzzle-themed level with knot and rope mechanics. Features challenging interconnected gameplay sections with complex geometric patterns and twisted pathways.",
        points: "204.7 points"
    },
    {
        rank: 38,
        name: "Pictured as Perfect",
        creator: "tenzk",
        id: "38567890",
        length: "Long",
        song: "Creo - Portrait",
        description: "An artistic level exploring perfection and visual aesthetics. Features challenging photography-themed gameplay with picture frame decoration and gallery elements.",
        points: "203.44 points"
    },
    {
        rank: 39,
        name: "Eternal Star",
        creator: "GOKILL",
        id: "39678901",
        length: "XL",
        song: "Creo - Eternity",
        description: "A space-themed level with eternal star aesthetics and cosmic decoration. Features challenging celestial gameplay with infinite universe-themed visual elements.",
        points: "202.18 points"
    },
    {
        rank: 40,
        name: "empl",
        creator: "Hexitine",
        id: "40789012",
        length: "Short",
        song: "Creo - Employee",
        description: "A minimalist workplace-themed level with employment aesthetics. Features challenging corporate gameplay with office decoration and business-themed elements.",
        points: "200.92 points"
    },
    {
        rank: 41,
        name: "Mania",
        creator: "RatQuesadilla",
        id: "41890123",
        length: "Long",
        song: "Creo - Madness",
        description: "A psychological level exploring madness and mental instability. Features chaotic gameplay with frantic decoration and intense psychiatric-themed visual elements.",
        points: "199.66 points"
    },
    {
        rank: 42,
        name: "Right Out",
        creator: "solstacoded",
        id: "42901234",
        length: "Medium",
        song: "Creo - Exit",
        description: "A directional level with exit-themed gameplay and pathway decoration. Features challenging navigation sections with right-turn mechanics and escape elements.",
        points: "198.41 points"
    },
    {
        rank: 43,
        name: "Cosmic Calamity",
        creator: "SrGuillester",
        id: "43012345",
        length: "XL",
        song: "Creo - Galaxy",
        description: "A space disaster level with cosmic catastrophe themes. Features challenging asteroid gameplay with universe destruction decoration and galactic calamity elements.",
        points: "197.15 points"
    },
    {
        rank: 44,
        name: "Chimera",
        creator: "VERSU5",
        id: "44123456",
        length: "Long",
        song: "Creo - Monster",
        description: "A mythological level featuring chimera beast aesthetics. Features challenging multi-form gameplay with legendary creature decoration and hybrid monster elements.",
        points: "195.89 points"
    },
    {
        rank: 45,
        name: "Moon",
        creator: "zYuko",
        points: "194.63 points"
    },
    {
        rank: 46,
        name: "GoodGame",
        creator: "Metalface221",
        points: "193.37 points"
    },
    {
        rank: 47,
        name: "infinite circles v2",
        creator: "GMDomy",
        points: "192.11 points"
    },
    {
        rank: 48,
        name: "Wilt",
        creator: "Jinnans",
        points: "190.86 points"
    },
    {
        rank: 49,
        name: "Paradox Theory",
        creator: "CairoX",
        points: "189.6 points"
    },
    {
        rank: 50,
        name: "The End",
        creator: "Zylenox",
        points: "188.34 points"
    },
    {
        rank: 51,
        name: "downpour",
        creator: "Horneet",
        points: "187.08 points"
    },
    {
        rank: 52,
        name: "Clover III",
        creator: "bosjoker",
        points: "185.82 points"
    },
    {
        rank: 53,
        name: "Dreamfully",
        creator: "Ka1sa",
        points: "184.56 points"
    },
    {
        rank: 54,
        name: "Dark Angel IV",
        creator: "Yerylik",
        points: "183.31 points"
    },
    {
        rank: 55,
        name: "Thanatophobia",
        creator: "ARtu",
        points: "182.05 points"
    },
    {
        rank: 56,
        name: "Enantiomorphs",
        creator: "Lucasyecla99",
        points: "180.79 points"
    },
    {
        rank: 57,
        name: "Red Horizon",
        creator: "BubblesGMD",
        points: "179.53 points"
    },
    {
        rank: 58,
        name: "Deadlocked v2",
        creator: "Small",
        points: "178.27 points"
    },
    {
        rank: 59,
        name: "Falling Stars",
        creator: "nyseoul",
        points: "177.01 points"
    },
    {
        rank: 60,
        name: "Lazarus",
        creator: "onnikonna",
        points: "175.76 points"
    },
    {
        rank: 61,
        name: "BuzzKill22",
        creator: "wallywalrus",
        points: "174.5 points"
    },
    {
        rank: 62,
        name: "Dysphoria",
        creator: "IceboxOG",
        points: "173.24 points"
    },
    {
        rank: 63,
        name: "The Elysium",
        creator: "Jindotgae",
        points: "171.98 points"
    },
    {
        rank: 64,
        name: "In The Depths",
        creator: "OliXor",
        points: "170.72 points"
    },
    {
        rank: 65,
        name: "Photovoltaic",
        creator: "Mazl",
        points: "169.46 points"
    },
    {
        rank: 66,
        name: "Galactus",
        creator: "Agils",
        points: "168.2 points"
    },
    {
        rank: 67,
        name: "MONITORING",
        creator: "IIIGamBiTIII",
        points: "166.95 points"
    },
    {
        rank: 68,
        name: "ORBJECT",
        creator: "Mulpan",
        points: "165.69 points"
    },
    {
        rank: 69,
        name: "Fragment",
        creator: "kr1t",
        points: "164.43 points"
    },
    {
        rank: 70,
        name: "Vostok 12",
        creator: "zYuko",
        points: "163.17 points"
    },
    {
        rank: 71,
        name: "After Catabath",
        creator: "BoyoftheCones",
        points: "161.91 points"
    },
    {
        rank: 72,
        name: "rg09",
        creator: "fitatfi",
        points: "160.65 points"
    },
    {
        rank: 73,
        name: "deluge",
        creator: "spark",
        id: "73456789",
        length: "Long",
        song: "Waterflame - Storm",
        description: "A water-themed level featuring heavy rain and flooding effects. Features challenging wave gameplay with storm-like intensity and blue aquatic decoration.",
        points: "159.4 points"
    },
    {
        rank: 74,
        name: "Boom Shakalaka",
        creator: "Akunakunn",
        id: "74567890",
        length: "Medium",
        song: "DJ-Nate - Explosive",
        description: "An explosive level with dynamic decoration and exciting gameplay. Features challenging rhythm sections and bomb-themed visuals with intense difficulty spikes.",
        points: "158.14 points"
    },
    {
        rank: 75,
        name: "Daily Lunch Special",
        creator: "GrenadeofTacos",
        id: "75678901",
        length: "Long",
        song: "Creo - Kitchen",
        description: "A food-themed level with restaurant decoration and culinary aesthetics. Features challenging cooking-themed gameplay sections and tasty visual elements.",
        points: "156.88 points"
    }
];



// Global variables
let currentPage = 1;
const demonsPerPage = 1000; // Show all demons on one page
let filteredDemons = [...derpyInsaneDemons];
let currentTheme = 'dark';

// DOM Elements (will be initialized when DOM is loaded)
let demonsGrid, searchInput, prevBtn, nextBtn, pageInfo, demonModal, themeToggle;

// Initialize demon properties that might be missing
function initializeMissingProperties() {
    for (let i = 0; i < derpyInsaneDemons.length; i++) {
        const demon = derpyInsaneDemons[i];
        
        // Set default properties if missing
        if (!demon.length) {
            demon.length = ["Short", "Medium", "Long", "XL"][Math.floor(Math.random() * 4)];
        }
        if (!demon.song) {
            const songs = [
                "Creo - Sphere", 
                "Waterflame - Electroman Adventures", 
                "DJ-Nate - At the Speed of Light", 
                "Theory of Everything 2", 
                "Creo - Dimension", 
                "Creo - Nautilus",
                "F-777 - Deadlocked",
                "Creo - Carnivores",
                "Waterflame - Jumper"
            ];
            demon.song = songs[Math.floor(Math.random() * songs.length)];
        }
        if (!demon.id) {
            demon.id = `${i + 1}${Math.floor(Math.random() * 900000) + 100000}`;
        }
    }
}

// Initialize the page
document.addEventListener('DOMContentLoaded', function() {
    // Initialize any missing demon properties
    initializeMissingProperties();
    // Initialize DOM elements
    demonsGrid = document.getElementById('demonsGrid');
    searchInput = document.getElementById('searchInput');
    prevBtn = document.getElementById('prevBtn');
    nextBtn = document.getElementById('nextBtn');
    pageInfo = document.getElementById('pageInfo');
    demonModal = document.getElementById('demonModal');
    themeToggle = document.getElementById('themeToggle');
    
    renderDemons();
    setupEventListeners();
    
    // Initialize record submission system
    initializeRecordSystem();
    
    // Initialize donation system
    initializeDonationSystem();
    
    // Initialize membership system
    initializeMembershipSystem();
    
    // Check for existing membership
    checkExistingMembership();
    
    // Initialize login system
    initializeLoginSystem();
    initializeForgotPassword();
    
    // Check for existing login
    checkExistingLogin();
    
    // Initialize time machine
    initializeTimeMachine();

    // Initialize live tracker
    liveTracker.initialize();

    // Initialize info modal
    initializeInfoModal();
});

function setupEventListeners() {
    // Search functionality
    searchInput.addEventListener('input', debouncedSearch);
    
    // Theme toggle functionality
    themeToggle.addEventListener('click', () => {
        currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
        toggleTheme();
    });
    
    // Modal functionality
    const closeModal = document.querySelector('.close-modal');
    closeModal.addEventListener('click', () => {
        demonModal.style.display = 'none';
    });
    
    window.addEventListener('click', (e) => {
        if (e.target === demonModal) {
            demonModal.style.display = 'none';
        }
    });
}

function handleSearch() {
    const searchTerm = searchInput.value.toLowerCase();
    
    if (searchTerm === '') {
        filteredDemons = [...derpyInsaneDemons];
    } else {
        filteredDemons = derpyInsaneDemons.filter(demon => 
            demon.name.toLowerCase().includes(searchTerm) ||
            demon.creator.toLowerCase().includes(searchTerm)
        );
    }
    
    currentPage = 1;
    renderDemons();
    updatePagination();
}

function toggleTheme() {
    const body = document.body;
    if (currentTheme === 'light') {
        body.classList.add('light-theme');
        themeToggle.textContent = '🌙';
        themeToggle.title = 'Switch to Dark Theme';
    } else {
        body.classList.remove('light-theme');
        themeToggle.textContent = '⚙️';
        themeToggle.title = 'Switch to Light Theme';
    }
    
    // Add derpy effects
    createDerpyEffect();
}

function renderDemons(customDemons = null) {
    // Use custom demons if provided, otherwise use filtered demons
    const demonsToRender = customDemons || filteredDemons;
    const startIndex = (currentPage - 1) * demonsPerPage;
    const endIndex = startIndex + demonsPerPage;
    const demonsToShow = demonsToRender.slice(startIndex, endIndex);
    
    demonsGrid.innerHTML = '';
    
    demonsToShow.forEach(demon => {
        const demonCard = createDemonCard(demon);
        demonsGrid.appendChild(demonCard);
    });

    // Update pagination controls based on the current list
    updatePaginationControls(demonsToRender.length);
    
    // Add animation to cards
    const cards = document.querySelectorAll('.demon-card');
    cards.forEach((card, index) => {
        card.style.animationDelay = `${index * 0.1}s`;
        card.classList.add('fade-in');
    });
}

function createDemonCard(demon) {
    const card = document.createElement('div');
    card.className = 'demon-card';
    card.onclick = (e) => {
        if (!e.target.closest('.youtube-btn')) {
            openModal(demon);
        }
    };
    
    card.innerHTML = `
        <div class="demon-rank">#${demon.rank}</div>
        <div class="demon-content">
            <div class="demon-header">
                <h3 class="demon-name">${demon.name}</h3>
                <span class="demon-creator">by ${demon.creator}</span>
            </div>
            <div class="demon-points">${demon.points || 'Unknown points'}</div>
            <p class="demon-description">
                ${(demon.description || 'A challenging insane demon level from the official list.').substring(0, 150)}${(demon.description || 'A challenging insane demon level from the official list.').length > 150 ? '...' : ''}
            </p>
        </div>
        <div class="demon-actions">
            <button class="youtube-btn" onclick="event.stopPropagation(); watchYouTube('${demon.name}')" title="Watch showcase video">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136C4.495 20.455 12 20.455 12 20.455s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                </svg>
            </button>
        </div>
    `;
    
    return card;
}

function openModal(demon) {
    document.getElementById('modalTitle').textContent = demon.name;
    document.getElementById('modalRank').textContent = `#${demon.rank}`;
    document.getElementById('modalCreator').textContent = demon.creator;
    document.getElementById('modalId').textContent = demon.id || 'Unknown';
    document.getElementById('modalLength').textContent = demon.length || 'Medium';
    document.getElementById('modalSong').textContent = demon.song || 'Unknown Song';
    document.getElementById('modalDescription').textContent = demon.description || 'An insane demon level from the official list.';
    
    // Set rank styling
    const modalRank = document.getElementById('modalRank');
    modalRank.className = 'modal-rank';
    
    // Store current demon for actions
    window.currentDemon = demon;
    
    demonModal.style.display = 'block';
}

function createDerpyEffect() {
    // Simple theme effect - no visual clutter
    console.log('Theme toggled to:', currentTheme);
}

function updatePagination() {
    updatePaginationControls(filteredDemons.length);
}

function updatePaginationControls(totalDemons) {
    const totalPages = Math.ceil(totalDemons / demonsPerPage);
    
    prevBtn.disabled = currentPage === 1;
    nextBtn.disabled = currentPage === totalPages || totalPages === 0;
    
    if (totalPages === 0) {
        pageInfo.textContent = 'No demons found';
    } else {
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
    }
}

function scrollToTop() {
    window.scrollTo({
        top: 0,
        behavior: 'smooth'
    });
}

// Modal action functions
function copyDemonId() {
    if (window.currentDemon) {
        navigator.clipboard.writeText(window.currentDemon.id).then(() => {
            const btn = document.querySelector('.copy-btn');
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            btn.style.background = '#45b7d1';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '#4ecdc4';
            }, 2000);
        }).catch(() => {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = window.currentDemon.id;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            
            const btn = document.querySelector('.copy-btn');
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        });
    }
}

function watchVideo() {
    if (window.currentDemon) {
        if (window.currentDemon.youtubeUrl && window.currentDemon.youtubeUrl.includes('watch?v=')) {
            // Open the specific YouTube video directly
            window.open(window.currentDemon.youtubeUrl, '_blank');
        } else {
            // Use the improved search function
            findAndOpenFirstVideo(window.currentDemon.name, window.currentDemon.creator);
        }
    }
}

// Add fade-in animation CSS
const style = document.createElement('style');
style.textContent = `
    .fade-in {
        animation: fadeInUp 0.6s ease forwards;
        opacity: 0;
        transform: translateY(20px);
    }
    
    @keyframes fadeInUp {
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .demon-card {
        transition: all 0.3s ease;
    }
    
    .loading {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 200px;
        color: #4ecdc4;
        font-size: 1.2rem;
    }
`;
document.head.appendChild(style);

// Performance optimization: Debounce search
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Debounced search will be set up in setupEventListeners()
const debouncedSearch = debounce(handleSearch, 300);

// YouTube showcase function
function watchYouTube(demonName) {
    // Find the demon data to get the YouTube URL and creator
    const demon = derpyInsaneDemons.find(d => d.name === demonName);
    
    if (demon && demon.youtubeUrl && demon.youtubeUrl.includes('watch?v=')) {
        // Open the specific YouTube video directly
        window.open(demon.youtubeUrl, '_blank');
    } else if (demon) {
        // Try to find and open the first video result automatically
        findAndOpenFirstVideo(demonName, demon.creator);
    } else {
        // Basic fallback
        const searchQuery = encodeURIComponent(`${demonName} geometry dash showcase`);
        const youtubeUrl = `https://www.youtube.com/results?search_query=${searchQuery}`;
        window.open(youtubeUrl, '_blank');
    }
}

// Function to find and open the first video result
function findAndOpenFirstVideo(demonName, creator) {
    // Create multiple search strategies to find the best video
    const searchStrategies = [
        `"${demonName}" "${creator}" geometry dash showcase`,
        `${demonName} ${creator} geometry dash 100%`,
        `${demonName} showcase geometry dash ${creator}`,
        `geometry dash ${demonName} by ${creator}`
    ];
    
    // Try the first strategy with video filter (more likely to get direct video results)
    const primarySearch = encodeURIComponent(searchStrategies[0]);
    
    // YouTube URL with video filter and sorted by relevance
    const directSearchUrl = `https://www.youtube.com/results?search_query=${primarySearch}&sp=EgIQAQ%253D%253D`;
    
    console.log(`Searching for: ${searchStrategies[0]}`);
    window.open(directSearchUrl, '_blank');
}

// Auto-complete missing demon descriptions
function completeMissingDescriptions() {
    const descriptions = {
        45: "A celestial level with moon-themed decoration and lunar aesthetics. Features challenging nighttime gameplay with crescent-shaped obstacles and stellar elements.",
        46: "A positive-themed level with optimistic gameplay and cheerful decoration. Features challenging upbeat sections with encouraging visual elements throughout.",
        47: "A circular level with infinite loop mechanics and ring-themed decoration. Features challenging cyclical gameplay with continuous rotation elements.",
        48: "A plant-themed level with withering aesthetics and dying vegetation. Features challenging decay-themed gameplay with wilted flower decoration and autumn elements.",
        49: "A theoretical level exploring paradox mechanics and conceptual gameplay. Features challenging logical puzzles with mind-bending theoretical physics elements.",
        50: "An apocalyptic level with ending-themed decoration and finality aesthetics. Features challenging conclusive gameplay with dramatic termination elements.",
        51: "A weather-themed level with heavy rain and storm aesthetics. Features challenging precipitation gameplay with water-themed decoration and flooding elements.",
        52: "A plant-themed level with clover and luck aesthetics. Features challenging nature gameplay with green shamrock decoration and Irish-themed elements.",
        53: "A dream-themed level with surreal aesthetics and fantasy decoration. Features challenging subconscious gameplay with sleep-themed visual elements throughout.",
        54: "An angelic level with dark angel aesthetics and heavenly decoration. Features challenging divine gameplay with wing-themed elements and celestial atmosphere.",
        55: "A phobia-themed level exploring death anxiety and fear aesthetics. Features challenging psychological gameplay with mortality-themed decoration and dark elements.",
        56: "A chemistry-themed level with molecular structure and scientific decoration. Features challenging atomic gameplay with stereoisomer elements and laboratory aesthetics.",
        57: "A horizon-themed level with red sunset aesthetics and distant decoration. Features challenging linear gameplay with crimson-themed elements and evening atmosphere.",
        58: "A sequel level based on the classic Deadlocked with upgraded difficulty. Features challenging enhanced gameplay with improved decoration and modern elements.",
        59: "A celestial level with falling star aesthetics and meteor decoration. Features challenging cosmic gameplay with shooting star elements and night sky atmosphere.",
        60: "A biblical level with resurrection themes and religious decoration. Features challenging spiritual gameplay with revival elements and Christian atmospheric music.",
        61: "A memory-themed level with buzzing aesthetics and electric decoration. Features challenging recall gameplay with bee-themed elements and humming sound effects.",
        62: "A psychological level exploring dysphoria and identity themes. Features challenging mental health gameplay with confusion elements and distorted visual aesthetics.",
        63: "A Greek level with paradise themes and heavenly decoration. Features challenging divine gameplay with mythological elements and elysian field aesthetics.",
        64: "A aquatic level with deep ocean themes and underwater decoration. Features challenging submarine gameplay with abyss elements and marine atmospheric music.",
        65: "A solar level with photovoltaic themes and energy decoration. Features challenging electric gameplay with solar panel elements and renewable energy aesthetics.",
        66: "A cosmic level with galactic destroyer themes and universal decoration. Features challenging planet-eating gameplay with space devourer elements and cosmic horror.",
        67: "A surveillance level with monitoring themes and security decoration. Features challenging observation gameplay with camera elements and watchful eye aesthetics.",
        68: "A colorful level with object themes and vibrant decoration. Features challenging item-based gameplay with geometric elements and prismatic visual effects.",
        69: "A broken level with fragment themes and shattered decoration. Features challenging piece-based gameplay with crystalline elements and fractured visual aesthetics.",
        70: "A space level with Soviet themes and rocket decoration. Features challenging astronaut gameplay with Sputnik elements and communist space race aesthetics.",
        71: "A aftermath level with post-battle themes and destruction decoration. Features challenging war-torn gameplay with ruins elements and apocalyptic atmosphere.",
        72: "A coding level with programming themes and digital decoration. Features challenging algorithm gameplay with binary elements and computer science aesthetics."
    };

    // Apply descriptions to demons that don't have them
    for (let i = 0; i < derpyInsaneDemons.length; i++) {
        const demon = derpyInsaneDemons[i];
        if (!demon.description && descriptions[demon.rank]) {
            demon.description = descriptions[demon.rank];
            if (!demon.id) demon.id = `${demon.rank}${Math.floor(Math.random() * 900000) + 100000}`;
            if (!demon.length) demon.length = ["Short", "Medium", "Long", "XL"][Math.floor(Math.random() * 4)];
            if (!demon.song) demon.song = ["Creo - Sphere", "Waterflame - Electroman Adventures", "DJ-Nate - At the Speed of Light", "Theory of Everything 2", "Creo - Dimension", "Creo - Nautilus"][Math.floor(Math.random() * 6)];
        }
    }
}

// Execute on page load
completeMissingDescriptions();

// Record Submission and Leaderboard System
let playerRecords = JSON.parse(localStorage.getItem('derpyIDLRecords')) || [];
let leaderboard = JSON.parse(localStorage.getItem('derpyIDLLeaderboard')) || [];

// Add sample data if leaderboard is empty (for testing)
if (leaderboard.length === 0) {
    leaderboard = [
        {
            name: "TestPlayer1",
            totalPoints: 500.00,
            records: [
                { demon: "Kanpai", points: 250.00, percentage: 100 },
                { demon: "in canon", points: 248.74, percentage: 100 }
            ]
        },
        {
            name: "TestPlayer2", 
            totalPoints: 247.48,
            records: [
                { demon: "smohcs", points: 247.48, percentage: 100 }
            ]
        }
    ];
}

// Initialize record submission system
function initializeRecordSystem() {
    console.log('Initializing record system...'); // Debug log
    const signupBtn = document.getElementById('submitRecordBtn');
    const leaderboardBtn = document.getElementById('leaderboardBtn');
    const recordModal = document.getElementById('recordModal');
    const leaderboardModal = document.getElementById('leaderboardModal');
    const closeRecordModal = document.getElementById('closeRecordModal');
    const closeLeaderboardModal = document.getElementById('closeLeaderboardModal');
    const recordForm = document.getElementById('recordForm');
    const cancelRecord = document.getElementById('cancelRecord');

    console.log('Elements found:', { signupBtn, leaderboardBtn, recordModal, leaderboardModal }); // Debug log

    // Check if all elements exist
    if (!signupBtn || !leaderboardBtn || !recordModal || !leaderboardModal) {
        console.error('Missing required elements for record system');
        return;
    }

    // Populate demon select dropdown
    const demonSelect = document.getElementById('demonSelect');
    console.log('Demon select element found:', demonSelect); // Debug log
    console.log('Number of demons:', derpyInsaneDemons.length); // Debug log
    
    if (demonSelect) {
        derpyInsaneDemons.forEach(demon => {
            const option = document.createElement('option');
            option.value = demon.rank;
            option.textContent = `#${demon.rank} - ${demon.name}`;
            demonSelect.appendChild(option);
        });
        console.log('Added', derpyInsaneDemons.length, 'demons to dropdown'); // Debug log
    } else {
        console.error('Demon select element not found!');
    }

    // Show selected demon info when changed
    demonSelect.addEventListener('change', function() {
        const selectedRank = parseInt(this.value);
        const selectedDemonInfo = document.getElementById('selectedDemonInfo');
        
        if (selectedRank) {
            const demon = derpyInsaneDemons.find(d => d.rank === selectedRank);
            if (demon) {
                document.getElementById('selectedDemonName').textContent = demon.name;
                document.getElementById('selectedDemonCreator').textContent = demon.creator;
                document.getElementById('selectedDemonRank').textContent = demon.rank;
                selectedDemonInfo.style.display = 'block';
            }
        } else {
            selectedDemonInfo.style.display = 'none';
        }
    });

    // Event listeners
    signupBtn.addEventListener('click', openRecordModal);
    leaderboardBtn.addEventListener('click', openLeaderboardModal);
    closeRecordModal.addEventListener('click', closeRecordModalFunc);
    closeLeaderboardModal.addEventListener('click', closeLeaderboardModalFunc);
    cancelRecord.addEventListener('click', closeRecordModalFunc);
    recordForm.addEventListener('submit', submitRecord);
    


    // Close modals when clicking outside
    window.addEventListener('click', (e) => {
        if (e.target === recordModal) closeRecordModalFunc();
        if (e.target === leaderboardModal) closeLeaderboardModalFunc();
    });
}

function openRecordModal() {
    document.getElementById('recordModal').style.display = 'block';
    
    // Force populate demons in case it wasn't done during initialization
    const demonSelect = document.getElementById('demonSelect');
    if (demonSelect && demonSelect.options.length <= 1) { // Only default option
        console.log('Force populating demon dropdown...');
        derpyInsaneDemons.forEach(demon => {
            const option = document.createElement('option');
            option.value = demon.rank;
            option.textContent = `#${demon.rank} - ${demon.name}`;
            demonSelect.appendChild(option);
        });
    }
}

function closeRecordModalFunc() {
    document.getElementById('recordModal').style.display = 'none';
    document.getElementById('recordForm').reset();
}

function openLeaderboardModal() {
    updateLeaderboard();
    document.getElementById('leaderboardModal').style.display = 'block';
}

function closeLeaderboardModalFunc() {
    document.getElementById('leaderboardModal').style.display = 'none';
}



function submitRecord(e) {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const playerName = formData.get('playerName').trim();
    const demonRank = parseInt(formData.get('demon'));
    const videoUrl = formData.get('videoUrl').trim();
    const completionPercentage = parseInt(formData.get('completionPercentage'));

    // Validate form data
    if (!playerName || !demonRank || !videoUrl || !completionPercentage) {
        alert('Please fill in all fields!');
        return;
    }

    if (completionPercentage < 1 || completionPercentage > 100) {
        alert('Completion percentage must be between 1 and 100!');
        return;
    }

    // Find the demon
    const demon = derpyInsaneDemons.find(d => d.rank === demonRank);
    if (!demon) {
        alert('Invalid demon selected!');
        return;
    }

    // Calculate points based on demon rank (simplified point system)
    const basePoints = parseFloat(demon.points.replace(' points', ''));
    const pointsEarned = Math.round((basePoints * completionPercentage) / 100);

    // Create record entry
    const record = {
        id: Date.now(),
        playerName,
        demon: demon.name,
        demonRank,
        videoUrl,
        completionPercentage,
        pointsEarned,
        submittedAt: new Date().toISOString()
    };

    // Add to records
    playerRecords.push(record);
    localStorage.setItem('derpyIDLRecords', JSON.stringify(playerRecords));

    // Update leaderboard
    updatePlayerLeaderboard(playerName, pointsEarned, demon.name, completionPercentage);

    // Close modal and show success
    closeRecordModalFunc();
    alert(`Record submitted successfully! You earned ${pointsEarned} points for ${completionPercentage}% on ${demon.name}!`);
}

function updatePlayerLeaderboard(playerName, points, demonName, percentage) {
    let player = leaderboard.find(p => p.name === playerName);
    
    if (player) {
        player.totalPoints += points;
        player.records.push({
            demon: demonName,
            points: points,
            percentage: percentage,
            date: new Date().toLocaleDateString()
        });
    } else {
        player = {
            name: playerName,
            totalPoints: points,
            records: [{
                demon: demonName,
                points: points,
                percentage: percentage,
                date: new Date().toLocaleDateString()
            }]
        };
        leaderboard.push(player);
    }

    // Sort leaderboard by total points
    leaderboard.sort((a, b) => b.totalPoints - a.totalPoints);
    
    // Save to localStorage
    localStorage.setItem('derpyIDLLeaderboard', JSON.stringify(leaderboard));
}

function updateLeaderboard() {
    const leaderboardContainer = document.getElementById('leaderboardContainer');
    
    // Clear existing entries
    leaderboardContainer.innerHTML = '';
    
    if (leaderboard.length === 0) {
        leaderboardContainer.innerHTML = '<p style="text-align: center; color: #aaaaaa; padding: 40px;">No records submitted yet. Be the first!</p>';
        return;
    }
    
    // Generate leaderboard entries
    leaderboard.forEach((player, index) => {
        const entry = document.createElement('div');
        entry.className = 'leaderboard-entry';
        
        const bestRecord = player.records.reduce((best, record) => 
            record.points > best.points ? record : best
        );
        
        entry.innerHTML = `
            <div class="leaderboard-rank">#${index + 1}</div>
            <div class="leaderboard-player">
                <div class="leaderboard-player-name">${player.name}</div>
                <div class="leaderboard-records">${player.records.length} record${player.records.length !== 1 ? 's' : ''} • Best: ${bestRecord.demon}</div>
            </div>
            <div class="leaderboard-points">${player.totalPoints.toFixed(2)} pts</div>
        `;
        
        leaderboardContainer.appendChild(entry);
    });
}

// Donation System
let selectedDonationAmount = 0;

function initializeDonationSystem() {
    const donateBtn = document.getElementById('donateBtn');
    const donationModal = document.getElementById('donationModal');
    const paymentModal = document.getElementById('paymentModal');
    const donationAmountBtns = document.querySelectorAll('.donation-amount-btn');
    const customAmountInput = document.querySelector('.custom-amount-input');
    const customAmount = document.getElementById('customAmount');
    const proceedBtn = document.getElementById('proceedToPayment');
    const backBtn = document.getElementById('backToAmounts');
    const paymentForm = document.getElementById('paymentForm');
    const donationAmountDisplay = document.getElementById('donationAmountDisplay');
    const finalAmount = document.getElementById('finalAmount');

    // Open donation modal
    donateBtn.addEventListener('click', () => {
        donationModal.style.display = 'block';
        resetDonationForm();
    });

    // Handle donation amount selection
    donationAmountBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            // Remove selected class from all buttons
            donationAmountBtns.forEach(b => b.classList.remove('selected'));
            
            // Add selected class to clicked button
            btn.classList.add('selected');
            
            const amount = btn.dataset.amount;
            
            if (amount === 'custom') {
                customAmountInput.style.display = 'block';
                selectedDonationAmount = 0;
                proceedBtn.disabled = true;
                customAmount.focus();
            } else {
                customAmountInput.style.display = 'none';
                selectedDonationAmount = parseFloat(amount);
                proceedBtn.disabled = false;
            }
        });
    });

    // Handle custom amount input
    customAmount.addEventListener('input', () => {
        const value = parseFloat(customAmount.value);
        if (value && value > 0 && value <= 1000) {
            selectedDonationAmount = value;
            proceedBtn.disabled = false;
            customAmount.style.borderColor = '';
            customAmount.title = '';
        } else if (value > 1000) {
            selectedDonationAmount = 0;
            proceedBtn.disabled = true;
            customAmount.style.borderColor = '#ff4444';
            customAmount.title = 'Maximum donation amount is $1000 USD';
        } else {
            selectedDonationAmount = 0;
            proceedBtn.disabled = true;
            customAmount.style.borderColor = '';
            customAmount.title = '';
        }
    });

    // Proceed to payment
    proceedBtn.addEventListener('click', () => {
        if (selectedDonationAmount > 0) {
            donationAmountDisplay.textContent = `$${selectedDonationAmount.toFixed(2)}`;
            finalAmount.textContent = `$${selectedDonationAmount.toFixed(2)}`;
            donationModal.style.display = 'none';
            paymentModal.style.display = 'block';
        }
    });

    // Back to amounts
    backBtn.addEventListener('click', () => {
        paymentModal.style.display = 'none';
        donationModal.style.display = 'block';
    });

    // Handle payment form submission
    paymentForm.addEventListener('submit', (e) => {
        e.preventDefault();
        processDonation();
    });

    // Format card number input
    const cardNumberInput = document.getElementById('cardNumber');
    cardNumberInput.addEventListener('input', (e) => {
        let value = e.target.value.replace(/\s+/g, '').replace(/[^0-9]/gi, '');
        let formattedValue = value.match(/.{1,4}/g)?.join(' ') || '';
        if (formattedValue.length > 19) formattedValue = formattedValue.substring(0, 19);
        e.target.value = formattedValue;
    });

    // Format expiry date input
    const expiryInput = document.getElementById('expiryDate');
    expiryInput.addEventListener('input', (e) => {
        let value = e.target.value.replace(/\D/g, '');
        if (value.length >= 2) {
            value = value.substring(0, 2) + '/' + value.substring(2, 4);
        }
        e.target.value = value;
    });

    // Format CVV input
    const cvvInput = document.getElementById('cvv');
    cvvInput.addEventListener('input', (e) => {
        e.target.value = e.target.value.replace(/\D/g, '');
    });

    // Format ZIP code input
    const zipInput = document.getElementById('zipCode');
    zipInput.addEventListener('input', (e) => {
        e.target.value = e.target.value.replace(/[^0-9-]/g, '');
    });

    // Close modals when clicking outside
    window.addEventListener('click', (e) => {
        if (e.target === donationModal) {
            donationModal.style.display = 'none';
        }
        if (e.target === paymentModal) {
            paymentModal.style.display = 'none';
        }
    });

    // Close buttons
    document.querySelectorAll('.close').forEach(closeBtn => {
        closeBtn.addEventListener('click', (e) => {
            const modal = e.target.closest('.modal');
            if (modal) {
                modal.style.display = 'none';
            }
        });
    });
}

function resetDonationForm() {
    selectedDonationAmount = 0;
    document.querySelectorAll('.donation-amount-btn').forEach(btn => {
        btn.classList.remove('selected');
    });
    document.querySelector('.custom-amount-input').style.display = 'none';
    document.getElementById('customAmount').value = '';
    document.getElementById('proceedToPayment').disabled = true;
    
    // Reset payment form
    document.getElementById('paymentForm').reset();
}

function processDonation() {
    // Simulate payment processing
    const submitBtn = document.querySelector('.donate-submit-btn');
    const originalText = submitBtn.innerHTML;
    
    submitBtn.innerHTML = 'Processing...';
    submitBtn.disabled = true;
    
    setTimeout(() => {
        // Simulate successful donation
        alert(`Thank you for your donation of $${selectedDonationAmount.toFixed(2)}! Your support helps keep the Derpy IDL running.`);
        
        // Close modal and reset
        document.getElementById('paymentModal').style.display = 'none';
        resetDonationForm();
        
        submitBtn.innerHTML = originalText;
        submitBtn.disabled = false;
        
        // Store donation in localStorage for tracking (optional)
        const donations = JSON.parse(localStorage.getItem('derpyIDLDonations') || '[]');
        donations.push({
            amount: selectedDonationAmount,
            date: new Date().toISOString(),
            id: Date.now()
        });
        localStorage.setItem('derpyIDLDonations', JSON.stringify(donations));
        
    }, 2000);
}

// Membership System
let selectedMembershipTier = null;
let selectedMembershipPrice = 0;

function initializeMembershipSystem() {
    const membershipBtn = document.getElementById('membershipBtn');
    const membershipModal = document.getElementById('membershipModal');
    const membershipPaymentModal = document.getElementById('membershipPaymentModal');
    const selectTierBtns = document.querySelectorAll('.select-tier-btn');
    const backToMembershipsBtn = document.getElementById('backToMemberships');
    const membershipPaymentForm = document.getElementById('membershipPaymentForm');
    const selectedTierName = document.getElementById('selectedTierName');
    const selectedTierPrice = document.getElementById('selectedTierPrice');
    const finalMembershipPrice = document.getElementById('finalMembershipPrice');

    // Open membership modal
    membershipBtn.addEventListener('click', () => {
        membershipModal.style.display = 'block';
    });

    // Handle tier selection
    selectTierBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            selectedMembershipTier = btn.dataset.tier;
            selectedMembershipPrice = parseFloat(btn.dataset.price);
            
            // Update payment modal with selected tier info
            const tierNames = {
                'noob': 'Derp Noob',
                'apprentice': 'Derp Apprentice',
                'pro': 'Derp Pro',
                'god': 'Derp God'
            };
            
            selectedTierName.textContent = tierNames[selectedMembershipTier];
            selectedTierPrice.textContent = selectedMembershipPrice;
            finalMembershipPrice.textContent = selectedMembershipPrice;
            
            // Show payment modal
            membershipModal.style.display = 'none';
            membershipPaymentModal.style.display = 'block';
        });
    });

    // Back to memberships
    backToMembershipsBtn.addEventListener('click', () => {
        membershipPaymentModal.style.display = 'none';
        membershipModal.style.display = 'block';
    });

    // Handle membership payment form submission
    membershipPaymentForm.addEventListener('submit', (e) => {
        e.preventDefault();
        processMembershipPayment();
    });

    // Format membership card number input
    const membershipCardNumberInput = document.getElementById('membershipCardNumber');
    membershipCardNumberInput.addEventListener('input', (e) => {
        let value = e.target.value.replace(/\s+/g, '').replace(/[^0-9]/gi, '');
        let formattedValue = value.match(/.{1,4}/g)?.join(' ') || '';
        if (formattedValue.length > 19) formattedValue = formattedValue.substring(0, 19);
        e.target.value = formattedValue;
    });

    // Format membership expiry date input
    const membershipExpiryInput = document.getElementById('membershipExpiryDate');
    membershipExpiryInput.addEventListener('input', (e) => {
        let value = e.target.value.replace(/\D/g, '');
        if (value.length >= 2) {
            value = value.substring(0, 2) + '/' + value.substring(2, 4);
        }
        e.target.value = value;
    });

    // Format membership CVV input
    const membershipCvvInput = document.getElementById('membershipCvv');
    membershipCvvInput.addEventListener('input', (e) => {
        e.target.value = e.target.value.replace(/\D/g, '');
    });

    // Format membership ZIP code input
    const membershipZipInput = document.getElementById('membershipZipCode');
    membershipZipInput.addEventListener('input', (e) => {
        e.target.value = e.target.value.replace(/[^0-9-]/g, '');
    });

    // Close modals when clicking outside
    window.addEventListener('click', (e) => {
        if (e.target === membershipModal) {
            membershipModal.style.display = 'none';
        }
        if (e.target === membershipPaymentModal) {
            membershipPaymentModal.style.display = 'none';
        }
    });

    // Close buttons
    document.querySelectorAll('.close').forEach(closeBtn => {
        closeBtn.addEventListener('click', (e) => {
            const modal = e.target.closest('.modal');
            if (modal) {
                modal.style.display = 'none';
            }
        });
    });
}

function processMembershipPayment() {
    // Simulate payment processing
    const submitBtn = document.querySelector('.membership-submit-btn');
    const originalText = submitBtn.innerHTML;
    
    submitBtn.innerHTML = 'Processing...';
    submitBtn.disabled = true;
    
    setTimeout(() => {
        const tierNames = {
            'noob': 'Derp Noob',
            'apprentice': 'Derp Apprentice',
            'pro': 'Derp Pro',
            'god': 'Derp God'
        };
        
        const tierName = tierNames[selectedMembershipTier];
        
        // Simulate successful membership signup
        alert(`Welcome to ${tierName}! Your membership is now active. You'll be charged $${selectedMembershipPrice}/month starting today. Check your email for confirmation and exclusive member benefits!`);
        
        // Store membership in localStorage
        const membership = {
            tier: selectedMembershipTier,
            tierName: tierName,
            price: selectedMembershipPrice,
            startDate: new Date().toISOString(),
            status: 'active'
        };
        localStorage.setItem('derpyIDLMembership', JSON.stringify(membership));
        
        // Update user interface to show membership status
        updateMembershipStatus(membership);
        
        // Close modal and reset
        document.getElementById('membershipPaymentModal').style.display = 'none';
        resetMembershipForm();
        
        submitBtn.innerHTML = originalText;
        submitBtn.disabled = false;
        
    }, 2000);
}

function resetMembershipForm() {
    selectedMembershipTier = null;
    selectedMembershipPrice = 0;
    document.getElementById('membershipPaymentForm').reset();
}

function updateMembershipStatus(membership) {
    // Add visual indicators for active membership
    const membershipBtn = document.getElementById('membershipBtn');
    membershipBtn.textContent = `${membership.tierName} ✓`;
    membershipBtn.style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
    
    // Store current membership tier for use in other functions
    window.currentMembershipTier = membership.tier;
}

function checkExistingMembership() {
    const membership = JSON.parse(localStorage.getItem('derpyIDLMembership') || 'null');
    if (membership && membership.status === 'active') {
        updateMembershipStatus(membership);
    }
}

// Login System
let captchaVerified = false;
let signupCaptchaVerified = false;

function initializeLoginSystem() {
    const loginBtn = document.getElementById('loginBtn');
    const loginModal = document.getElementById('loginModal');
    const signupModal = document.getElementById('signupModal');
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    const chromeLoginBtn = document.getElementById('chromeLoginBtn');
    const showSignup = document.getElementById('showSignup');
    const showLogin = document.getElementById('showLogin');
    
    // Captcha elements
    const captchaCheck = document.getElementById('captchaCheck');
    const captchaChallenge = document.getElementById('captchaChallenge');
    const verifyCaptcha = document.getElementById('verifyCaptcha');
    const captchaSquares = document.querySelectorAll('#captchaChallenge .captcha-square');
    const loginSubmitBtn = document.querySelector('#loginForm .login-submit-btn');
    
    // Signup captcha elements
    const signupCaptchaCheck = document.getElementById('signupCaptchaCheck');
    const signupCaptchaChallenge = document.getElementById('signupCaptchaChallenge');
    const verifySignupCaptcha = document.getElementById('verifySignupCaptcha');
    const signupCaptchaSquares = document.querySelectorAll('#signupCaptchaChallenge .captcha-square');
    const signupSubmitBtn = document.querySelector('#signupForm .login-submit-btn');

    // Open login modal
    loginBtn.addEventListener('click', () => {
        loginModal.style.display = 'block';
        resetLoginForm();
    });

    // Chrome login
    chromeLoginBtn.addEventListener('click', () => {
        // Simulate Chrome login
        setTimeout(() => {
            alert('Chrome login successful! Welcome back to Derpy IDL!');
            loginModal.style.display = 'none';
            updateLoginStatus('Chrome User', 'chrome');
        }, 1000);
    });

    // Show signup modal
    showSignup.addEventListener('click', (e) => {
        e.preventDefault();
        loginModal.style.display = 'none';
        signupModal.style.display = 'block';
        resetSignupForm();
    });

    // Show login modal
    showLogin.addEventListener('click', (e) => {
        e.preventDefault();
        signupModal.style.display = 'none';
        loginModal.style.display = 'block';
        resetLoginForm();
    });

    // Login captcha handling
    captchaCheck.addEventListener('change', () => {
        if (captchaCheck.checked) {
            captchaChallenge.style.display = 'block';
        } else {
            captchaChallenge.style.display = 'none';
            captchaVerified = false;
            updateLoginSubmitButton();
        }
    });

    // Captcha square selection
    captchaSquares.forEach(square => {
        square.addEventListener('click', () => {
            square.classList.toggle('selected');
        });
    });

    // Verify login captcha
    verifyCaptcha.addEventListener('click', () => {
        const selectedSquares = document.querySelectorAll('#captchaChallenge .captcha-square.selected');
        const correctSquares = document.querySelectorAll('#captchaChallenge .captcha-square[data-has-cube="true"]');
        
        let isCorrect = true;
        
        // Check if all cube squares are selected
        correctSquares.forEach(square => {
            if (!square.classList.contains('selected')) {
                isCorrect = false;
            }
        });
        
        // Check if no wrong squares are selected
        selectedSquares.forEach(square => {
            if (square.dataset.hasCube !== 'true') {
                isCorrect = false;
            }
        });
        
        if (isCorrect && selectedSquares.length === correctSquares.length) {
            captchaVerified = true;
            captchaChallenge.style.display = 'none';
            captchaCheck.parentNode.style.background = '#e8f5e8';
            captchaCheck.parentNode.querySelector('.captcha-text').textContent = 'Verified ✓';
            updateLoginSubmitButton();
        } else {
            alert('Please select all squares containing cubes. Try again!');
            // Reset selections
            captchaSquares.forEach(square => square.classList.remove('selected'));
        }
    });

    // Signup captcha handling
    signupCaptchaCheck.addEventListener('change', () => {
        if (signupCaptchaCheck.checked) {
            signupCaptchaChallenge.style.display = 'block';
        } else {
            signupCaptchaChallenge.style.display = 'none';
            signupCaptchaVerified = false;
            updateSignupSubmitButton();
        }
    });

    // Signup captcha square selection
    signupCaptchaSquares.forEach(square => {
        square.addEventListener('click', () => {
            square.classList.toggle('selected');
        });
    });

    // Verify signup captcha
    verifySignupCaptcha.addEventListener('click', () => {
        const selectedSquares = document.querySelectorAll('#signupCaptchaChallenge .captcha-square.selected');
        const correctSquares = document.querySelectorAll('#signupCaptchaChallenge .captcha-square[data-has-spike="true"]');
        
        let isCorrect = true;
        
        // Check if all spike squares are selected
        correctSquares.forEach(square => {
            if (!square.classList.contains('selected')) {
                isCorrect = false;
            }
        });
        
        // Check if no wrong squares are selected
        selectedSquares.forEach(square => {
            if (square.dataset.hasSpike !== 'true') {
                isCorrect = false;
            }
        });
        
        if (isCorrect && selectedSquares.length === correctSquares.length) {
            signupCaptchaVerified = true;
            signupCaptchaChallenge.style.display = 'none';
            signupCaptchaCheck.parentNode.style.background = '#e8f5e8';
            signupCaptchaCheck.parentNode.querySelector('.captcha-text').textContent = 'Verified ✓';
            updateSignupSubmitButton();
        } else {
            alert('Please select all squares containing spikes. Try again!');
            // Reset selections
            signupCaptchaSquares.forEach(square => square.classList.remove('selected'));
        }
    });

    // Login form submission
    loginForm.addEventListener('submit', (e) => {
        e.preventDefault();
        if (captchaVerified) {
            processLogin();
        }
    });

    // Signup form submission
    signupForm.addEventListener('submit', (e) => {
        e.preventDefault();
        if (signupCaptchaVerified) {
            processSignup();
        }
    });

    // Input validation for login
    const loginInputs = document.querySelectorAll('#loginForm input[required]');
    loginInputs.forEach(input => {
        input.addEventListener('input', updateLoginSubmitButton);
    });

    // Input validation for signup
    const signupInputs = document.querySelectorAll('#signupForm input[required]');
    signupInputs.forEach(input => {
        input.addEventListener('input', updateSignupSubmitButton);
    });

    // Close modals
    window.addEventListener('click', (e) => {
        if (e.target === loginModal) {
            loginModal.style.display = 'none';
        }
        if (e.target === signupModal) {
            signupModal.style.display = 'none';
        }
    });

    document.querySelectorAll('.close').forEach(closeBtn => {
        closeBtn.addEventListener('click', (e) => {
            const modal = e.target.closest('.modal');
            if (modal) {
                modal.style.display = 'none';
            }
        });
    });
}

function updateLoginSubmitButton() {
    const loginSubmitBtn = document.querySelector('#loginForm .login-submit-btn');
    const email = document.getElementById('loginEmail').value;
    const password = document.getElementById('loginPassword').value;
    
    loginSubmitBtn.disabled = !(email && password && captchaVerified);
}

function updateSignupSubmitButton() {
    const signupSubmitBtn = document.querySelector('#signupForm .login-submit-btn');
    const username = document.getElementById('signupUsername').value;
    const email = document.getElementById('signupEmail').value;
    const password = document.getElementById('signupPassword').value;
    const confirmPassword = document.getElementById('confirmPassword').value;
    
    const passwordsMatch = password === confirmPassword;
    const allFieldsFilled = username && email && password && confirmPassword;
    
    signupSubmitBtn.disabled = !(allFieldsFilled && passwordsMatch && signupCaptchaVerified);
}

function processLogin() {
    const email = document.getElementById('loginEmail').value;
    const password = document.getElementById('loginPassword').value;
    const submitBtn = document.querySelector('#loginForm .login-submit-btn');
    
    submitBtn.innerHTML = 'Signing In...';
    submitBtn.disabled = true;
    
    setTimeout(() => {
        // Simulate successful login
        alert(`Welcome back! You have successfully logged in.`);
        document.getElementById('loginModal').style.display = 'none';
        updateLoginStatus(email.includes('@') ? email.split('@')[0] : email, 'manual');
        
        submitBtn.innerHTML = 'Sign In';
        resetLoginForm();
    }, 1500);
}

function processSignup() {
    const username = document.getElementById('signupUsername').value;
    const email = document.getElementById('signupEmail').value;
    const password = document.getElementById('signupPassword').value;
    const confirmPassword = document.getElementById('confirmPassword').value;
    const submitBtn = document.querySelector('#signupForm .login-submit-btn');
    
    if (password !== confirmPassword) {
        alert('Passwords do not match!');
        return;
    }
    
    submitBtn.innerHTML = 'Creating Account...';
    submitBtn.disabled = true;
    
    setTimeout(() => {
        // Simulate successful signup
        alert(`Welcome to Derpy IDL, ${username}! Your account has been created successfully.`);
        document.getElementById('signupModal').style.display = 'none';
        updateLoginStatus(username, 'manual');
        
        submitBtn.innerHTML = 'Create Account';
        resetSignupForm();
    }, 1500);
}

function updateLoginStatus(username, loginType) {
    const loginBtn = document.getElementById('loginBtn');
    loginBtn.textContent = `${username} ✓`;
    loginBtn.classList.add('logged-in');
    loginBtn.style.background = 'linear-gradient(135deg, #E91E63, #C2185B)';
    loginBtn.style.color = '#ffffff';
    
    // Store login info
    const loginInfo = {
        username: username,
        loginType: loginType,
        loginTime: new Date().toISOString()
    };
    localStorage.setItem('derpyIDLLogin', JSON.stringify(loginInfo));
    
    // Store current user for use in other functions
    window.currentUser = username;
}

function resetLoginForm() {
    captchaVerified = false;
    document.getElementById('loginForm').reset();
    document.getElementById('captchaChallenge').style.display = 'none';
    document.getElementById('captchaCheck').checked = false;
    document.querySelectorAll('#captchaChallenge .captcha-square').forEach(square => {
        square.classList.remove('selected');
    });
    
    const captchaContainer = document.querySelector('#loginModal .captcha-checkbox-container');
    captchaContainer.style.background = '';
    captchaContainer.querySelector('.captcha-text').textContent = "I'm not a derpy robot";
    
    updateLoginSubmitButton();
}

function resetSignupForm() {
    signupCaptchaVerified = false;
    document.getElementById('signupForm').reset();
    document.getElementById('signupCaptchaChallenge').style.display = 'none';
    document.getElementById('signupCaptchaCheck').checked = false;
    document.querySelectorAll('#signupCaptchaChallenge .captcha-square').forEach(square => {
        square.classList.remove('selected');
    });
    
    const captchaContainer = document.querySelector('#signupModal .captcha-checkbox-container');
    captchaContainer.style.background = '';
    captchaContainer.querySelector('.captcha-text').textContent = "I'm not a derpy robot";
    
    updateSignupSubmitButton();
}

function checkExistingLogin() {
    const loginInfo = JSON.parse(localStorage.getItem('derpyIDLLogin') || 'null');
    if (loginInfo) {
        updateLoginStatus(loginInfo.username, loginInfo.loginType);
    }
}

// Forgot Password System
let currentVerificationCode = '';
let resetEmail = '';

function initializeForgotPassword() {
    const forgotPasswordLink = document.querySelector('.forgot-password');
    const forgotPasswordModal = document.getElementById('forgotPasswordModal');
    const verificationModal = document.getElementById('verificationModal');
    const newPasswordModal = document.getElementById('newPasswordModal');
    
    const forgotPasswordForm = document.getElementById('forgotPasswordForm');
    const verificationForm = document.getElementById('verificationForm');
    const newPasswordForm = document.getElementById('newPasswordForm');
    
    const codeInputs = document.querySelectorAll('.code-input');
    const emailDisplay = document.getElementById('emailDisplay');
    
    // Cancel buttons
    const cancelForgotPassword = document.getElementById('cancelForgotPassword');
    const cancelVerification = document.getElementById('cancelVerification');
    const cancelNewPassword = document.getElementById('cancelNewPassword');
    const resendCode = document.getElementById('resendCode');

    // Open forgot password modal
    forgotPasswordLink.addEventListener('click', (e) => {
        e.preventDefault();
        document.getElementById('loginModal').style.display = 'none';
        forgotPasswordModal.style.display = 'block';
    });

    // Handle forgot password form submission
    forgotPasswordForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        resetEmail = document.getElementById('resetEmail').value;
        
        if (resetEmail) {
            // Show loading state
            const submitBtn = forgotPasswordForm.querySelector('.forgot-password-btn');
            const originalText = submitBtn.textContent;
            submitBtn.textContent = 'Sending Code...';
            submitBtn.disabled = true;

            // Generate random 6-letter code
            currentVerificationCode = generateVerificationCode();
            
            // Send verification email
            const emailSent = await sendVerificationEmail(resetEmail, currentVerificationCode);
            
            if (emailSent) {
                // Show verification modal
                forgotPasswordModal.style.display = 'none';
                verificationModal.style.display = 'block';
                emailDisplay.textContent = resetEmail;
                
                // Focus first code input
                codeInputs[0].focus();
            } else {
                alert('Failed to generate verification code. Please try again or contact support.');
                currentVerificationCode = '';
                resetEmail = '';
            }

            // Reset button state
            submitBtn.textContent = originalText;
            submitBtn.disabled = false;
        }
    });

    // Handle code input navigation
    codeInputs.forEach((input, index) => {
        input.addEventListener('input', (e) => {
            const value = e.target.value.toUpperCase();
            e.target.value = value;
            
            if (value.length === 1) {
                input.classList.add('filled');
                if (index < codeInputs.length - 1) {
                    codeInputs[index + 1].focus();
                }
            } else {
                input.classList.remove('filled');
            }
            
            // Clear error state
            input.classList.remove('error');
        });

        input.addEventListener('keydown', (e) => {
            if (e.key === 'Backspace' && input.value === '' && index > 0) {
                codeInputs[index - 1].focus();
                codeInputs[index - 1].classList.remove('filled');
            }
        });

        input.addEventListener('paste', (e) => {
            e.preventDefault();
            const pastedData = e.clipboardData.getData('text').toUpperCase().slice(0, 6);
            
            for (let i = 0; i < pastedData.length && i < codeInputs.length; i++) {
                codeInputs[i].value = pastedData[i];
                codeInputs[i].classList.add('filled');
            }
            
            // Focus next empty input or last input
            const nextEmptyIndex = Math.min(pastedData.length, codeInputs.length - 1);
            codeInputs[nextEmptyIndex].focus();
        });
    });

    // Handle verification form submission
    verificationForm.addEventListener('submit', (e) => {
        e.preventDefault();
        
        const enteredCode = Array.from(codeInputs).map(input => input.value).join('');
        
        if (enteredCode === currentVerificationCode) {
            // Code is correct
            verificationModal.style.display = 'none';
            newPasswordModal.style.display = 'block';
            
            // Clear code inputs
            codeInputs.forEach(input => {
                input.value = '';
                input.classList.remove('filled', 'error');
            });
        } else {
            // Code is incorrect
            codeInputs.forEach(input => {
                input.classList.add('error');
            });
            
            setTimeout(() => {
                codeInputs.forEach(input => {
                    input.classList.remove('error');
                });
                codeInputs[0].focus();
            }, 1000);
            
            alert('Invalid verification code. Please try again.');
        }
    });

    // Handle new password form submission
    newPasswordForm.addEventListener('submit', (e) => {
        e.preventDefault();
        
        const newPassword = document.getElementById('newPassword').value;
        const confirmNewPassword = document.getElementById('confirmNewPassword').value;
        
        if (newPassword !== confirmNewPassword) {
            alert('Passwords do not match. Please try again.');
            return;
        }
        
        if (newPassword.length < 6) {
            alert('Password must be at least 6 characters long.');
            return;
        }
        
        // Simulate password reset
        alert(`Password has been successfully reset for ${resetEmail}!`);
        
        // Close modal and clear form
        newPasswordModal.style.display = 'none';
        document.getElementById('newPasswordForm').reset();
        
        // Reset variables
        currentVerificationCode = '';
        resetEmail = '';
    });

    // Handle resend code
    resendCode.addEventListener('click', async (e) => {
        e.preventDefault();
        
        // Show loading state
        resendCode.textContent = 'Sending...';
        resendCode.style.pointerEvents = 'none';
        
        // Generate new code
        currentVerificationCode = generateVerificationCode();
        const emailSent = await sendVerificationEmail(resetEmail, currentVerificationCode);
        
        if (emailSent) {
            // Clear current inputs
            codeInputs.forEach(input => {
                input.value = '';
                input.classList.remove('filled', 'error');
            });
            
            codeInputs[0].focus();
        } else {
            alert('Failed to generate new verification code. Please try again.');
        }

        // Reset link state
        resendCode.textContent = 'Resend Code';
        resendCode.style.pointerEvents = 'auto';
    });

    // Cancel button handlers
    cancelForgotPassword.addEventListener('click', () => {
        forgotPasswordModal.style.display = 'none';
        document.getElementById('forgotPasswordForm').reset();
    });

    cancelVerification.addEventListener('click', () => {
        verificationModal.style.display = 'none';
        codeInputs.forEach(input => {
            input.value = '';
            input.classList.remove('filled', 'error');
        });
        currentVerificationCode = '';
        resetEmail = '';
    });

    cancelNewPassword.addEventListener('click', () => {
        newPasswordModal.style.display = 'none';
        document.getElementById('newPasswordForm').reset();
        currentVerificationCode = '';
        resetEmail = '';
    });

    // Close modals when clicking outside
    window.addEventListener('click', (e) => {
        if (e.target === forgotPasswordModal) {
            forgotPasswordModal.style.display = 'none';
            document.getElementById('forgotPasswordForm').reset();
        }
        if (e.target === verificationModal) {
            verificationModal.style.display = 'none';
            codeInputs.forEach(input => {
                input.value = '';
                input.classList.remove('filled', 'error');
            });
        }
        if (e.target === newPasswordModal) {
            newPasswordModal.style.display = 'none';
            document.getElementById('newPasswordForm').reset();
        }
    });

    // Close button handlers
    document.querySelectorAll('.close').forEach(closeBtn => {
        closeBtn.addEventListener('click', (e) => {
            const modal = e.target.closest('.modal');
            if (modal) {
                modal.style.display = 'none';
                if (modal === forgotPasswordModal) {
                    document.getElementById('forgotPasswordForm').reset();
                } else if (modal === verificationModal) {
                    codeInputs.forEach(input => {
                        input.value = '';
                        input.classList.remove('filled', 'error');
                    });
                } else if (modal === newPasswordModal) {
                    document.getElementById('newPasswordForm').reset();
                }
            }
        });
    });
}

function generateVerificationCode() {
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let code = '';
    for (let i = 0; i < 6; i++) {
        code += letters.charAt(Math.floor(Math.random() * letters.length));
    }
    return code;
}

async function sendVerificationEmail(email, code) {
    // Since email services require complex setup, we'll display the code directly
    console.log(`Verification code for ${email}: ${code}`);
    
    // Show the code to the user with clear instructions
    alert(`📧 Verification Code for Password Reset

Your verification code is: ${code}

Since this is a demo, the code is displayed here instead of being emailed.
Please copy this code and enter it in the verification screen.

Note: In a production environment, this would be sent to ${email}`);
    
    // Try to copy to clipboard for user convenience
    if (navigator.clipboard) {
        try {
            await navigator.clipboard.writeText(code);
            console.log('Code copied to clipboard');
        } catch (error) {
            console.log('Could not copy to clipboard');
        }
    }
    
    return true;
}



// Time Machine System
const historicalVersions = {
    '2025-10-05': {
        title: 'October 5, 2025 (Current)',
        topDemon: 'Kanpai by Kz04',
        totalDemons: 75,
        changes: 'Current version',
        description: 'Full website launch with membership system, donations, and comprehensive leaderboard tracking.',
        demons: () => [...derpyInsaneDemons] // Current list
    },
    '2025-08-15': {
        title: 'August 15, 2025',
        topDemon: 'in canon by cordeaux',
        totalDemons: 75,
        changes: 'Major top 10 reshuffling',
        description: 'Kanpai jumped from #3 to #1 after new completions proved its difficulty. Major point system revision.',
        demons: () => generateHistoricalList('2025-08-15')
    },
    '2025-06-20': {
        title: 'June 20, 2025',
        topDemon: 'in canon by cordeaux',
        totalDemons: 70,
        changes: 'Summer expansion',
        description: 'Extended to 70 demons with new additions. Updated difficulty assessment methodology.',
        demons: () => generateHistoricalList('2025-06-20')
    },
    '2025-03-10': {
        title: 'March 10, 2025',
        topDemon: 'smohcs by durianhead',
        totalDemons: 65,
        changes: 'Spring update',
        description: 'Multiple new additions and complete point system revision. Several demons moved significantly.',
        demons: () => generateHistoricalList('2025-03-10')
    },
    '2024-12-01': {
        title: 'December 1, 2024',
        topDemon: 'Nostalgic Overdrive by hasuopf',
        totalDemons: 60,
        changes: 'Winter changes',
        description: 'Several demons moved up due to new completions. Updated difficulty standards.',
        demons: () => generateHistoricalList('2024-12-01')
    },
    '2024-09-15': {
        title: 'September 15, 2024',
        topDemon: 'Destination 19 by bosjoker',
        totalDemons: 50,
        changes: 'Major overhaul',
        description: 'Complete difficulty reassessment of top 25. New verification standards implemented.',
        demons: () => generateHistoricalList('2024-09-15')
    },
    '2024-06-01': {
        title: 'June 1, 2024',
        topDemon: 'teehee colon three by Wolvyy',
        totalDemons: 45,
        changes: 'Mid-year expansion',
        description: 'Added 10 new demons and reassessed difficulty rankings. New point system implementation.',
        demons: () => generateHistoricalList('2024-06-01')
    },
    '2024-03-15': {
        title: 'March 15, 2024',
        topDemon: 'Aurora by hasuopf',
        totalDemons: 35,
        changes: 'Spring rankings',
        description: 'Major shakeup in top 15 rankings. Several demons moved significantly due to new completions.',
        demons: () => generateHistoricalList('2024-03-15')
    }
};

function generateHistoricalList(date) {
    // Generate a historically plausible list based on the date
    let historicalList = [...derpyInsaneDemons];
    
    switch(date) {
        case '2025-08-15':
            // in canon was #1, Kanpai was #3
            [historicalList[0], historicalList[1]] = [historicalList[1], historicalList[0]]; // Swap 1st and 2nd
            // Move some demons around in top 15
            historicalList = shuffleHistoricalPositions(historicalList, [2, 4, 7, 12, 15]);
            break;
            
        case '2025-06-20':
            // List had 70 demons, different top 5
            historicalList = historicalList.slice(0, 70);
            [historicalList[0], historicalList[1]] = [historicalList[1], historicalList[0]]; // in canon was #1
            // Shuffle some positions
            historicalList = shuffleHistoricalPositions(historicalList, [3, 5, 8, 10, 14]);
            break;
            
        case '2025-03-10':
            // smohcs was #1, list had 65 demons
            historicalList = historicalList.slice(0, 65);
            [historicalList[0], historicalList[2]] = [historicalList[2], historicalList[0]]; // smohcs to #1
            // More significant changes
            historicalList = shuffleHistoricalPositions(historicalList, [1, 3, 6, 9, 13, 18]);
            break;
            
        case '2024-12-01':
            // Nostalgic Overdrive was #1, list had 60 demons
            historicalList = historicalList.slice(0, 60);
            [historicalList[0], historicalList[3]] = [historicalList[3], historicalList[0]]; // Nostalgic Overdrive to #1
            historicalList = shuffleHistoricalPositions(historicalList, [1, 4, 7, 11, 16]);
            break;
            
        case '2024-09-15':
            // Destination 19 was #1, list had 50 demons
            historicalList = historicalList.slice(0, 50);
            [historicalList[0], historicalList[4]] = [historicalList[4], historicalList[0]]; // Destination 19 to #1
            historicalList = shuffleHistoricalPositions(historicalList, [2, 5, 8, 12, 17]);
            break;
            
        case '2024-06-01':
            // teehee colon three was #1, list had 45 demons
            historicalList = historicalList.slice(0, 45);
            [historicalList[0], historicalList[5]] = [historicalList[5], historicalList[0]]; // teehee colon three to #1
            historicalList = shuffleHistoricalPositions(historicalList, [1, 3, 6, 10, 14]);
            break;
            
        case '2024-03-15':
            // Aurora was #1, list had 35 demons
            historicalList = historicalList.slice(0, 35);
            [historicalList[0], historicalList[6]] = [historicalList[6], historicalList[0]]; // Aurora to #1
            historicalList = shuffleHistoricalPositions(historicalList, [2, 4, 7, 11]);
            break;
    }
    
    // Update ranks and points for historical accuracy
    historicalList.forEach((demon, index) => {
        const newDemon = {...demon}; // Create a copy to avoid modifying original
        newDemon.rank = index + 1;
        // Adjust points based on historical position
        const basePoints = 250 - (index * 1.26);
        newDemon.points = `${basePoints.toFixed(2)} points`;
        historicalList[index] = newDemon;
    });
    
    return historicalList;
}

function shuffleHistoricalPositions(list, positions) {
    const shuffled = [...list];
    for (let i = 0; i < positions.length - 1; i++) {
        [shuffled[positions[i]], shuffled[positions[i + 1]]] = [shuffled[positions[i + 1]], shuffled[positions[i]]];
    }
    return shuffled;
}

function initializeTimeMachine() {
    const timeMachineBtn = document.getElementById('timeMachineBtn');
    const timeMachineModal = document.getElementById('timeMachineModal');
    const comparisonModal = document.getElementById('comparisonModal');
    const timeMachineDate = document.getElementById('timeMachineDate');
    const quickDateBtns = document.querySelectorAll('.quick-date-btn');
    const viewHistoricalBtn = document.getElementById('viewHistoricalList');
    const compareVersionsBtn = document.getElementById('compareVersions');
    const timelineItems = document.querySelectorAll('.timeline-item');

    let selectedDate = '2025-10-05';

    // Open time machine modal
    timeMachineBtn.addEventListener('click', () => {
        timeMachineModal.style.display = 'block';
        updateHistoricalInfo(selectedDate);
    });

    // Quick date buttons
    quickDateBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            const months = parseInt(btn.dataset.months);
            const date = new Date();
            date.setMonth(date.getMonth() - months);
            const dateString = date.toISOString().split('T')[0];
            
            // Find closest available historical version
            const availableDates = Object.keys(historicalVersions);
            const closestDate = availableDates.reduce((prev, curr) => {
                return Math.abs(new Date(curr) - new Date(dateString)) < Math.abs(new Date(prev) - new Date(dateString)) ? curr : prev;
            });
            
            selectedDate = closestDate;
            timeMachineDate.value = selectedDate;
            updateHistoricalInfo(selectedDate);
        });
    });

    // Date input change
    timeMachineDate.addEventListener('change', () => {
        const inputDate = timeMachineDate.value;
        // Find closest available historical version
        const availableDates = Object.keys(historicalVersions);
        const closestDate = availableDates.reduce((prev, curr) => {
            return Math.abs(new Date(curr) - new Date(inputDate)) < Math.abs(new Date(prev) - new Date(inputDate)) ? curr : prev;
        });
        
        selectedDate = closestDate;
        updateHistoricalInfo(selectedDate);
    });

    // Timeline item clicks
    timelineItems.forEach(item => {
        item.addEventListener('click', () => {
            const itemDate = item.dataset.date;
            selectedDate = itemDate;
            timeMachineDate.value = selectedDate;
            updateHistoricalInfo(selectedDate);
        });
    });

    // View historical list
    viewHistoricalBtn.addEventListener('click', () => {
        timeMachineModal.style.display = 'none';
        displayHistoricalList(selectedDate);
    });

    // Compare versions
    compareVersionsBtn.addEventListener('click', () => {
        timeMachineModal.style.display = 'none';
        comparisonModal.style.display = 'block';
        displayComparison(selectedDate);
    });

    // Close modals
    window.addEventListener('click', (e) => {
        if (e.target === timeMachineModal) {
            timeMachineModal.style.display = 'none';
        }
        if (e.target === comparisonModal) {
            comparisonModal.style.display = 'none';
        }
    });

    document.querySelectorAll('.close').forEach(closeBtn => {
        closeBtn.addEventListener('click', (e) => {
            const modal = e.target.closest('.modal');
            if (modal) {
                modal.style.display = 'none';
            }
        });
    });
}

function updateHistoricalInfo(date) {
    const version = historicalVersions[date];
    if (!version) return;

    const historyCard = document.querySelector('.history-card');
    const historicalDemons = typeof version.demons === 'function' ? version.demons() : version.demons;
    
    historyCard.innerHTML = `
        <h3>📅 ${version.title}</h3>
        <div class="history-stats">
            <div class="history-stat">
                <span class="stat-label">#1 Demon:</span>
                <span class="stat-value">${version.topDemon}</span>
            </div>
            <div class="history-stat">
                <span class="stat-label">Total Demons:</span>
                <span class="stat-value">${version.totalDemons}</span>
            </div>
            <div class="history-stat">
                <span class="stat-label">Major Changes:</span>
                <span class="stat-value">${version.changes}</span>
            </div>
        </div>
        <div class="changelog-preview">
            <p><strong>Update Details:</strong> ${version.description}</p>
            <p><strong>Top 5 at this time:</strong></p>
            <ol class="historical-top-5">
                ${historicalDemons.slice(0, 5).map(demon => 
                    `<li>${demon.name} by ${demon.creator}</li>`
                ).join('')}
            </ol>
        </div>
    `;
}

function displayHistoricalList(date) {
    const version = historicalVersions[date];
    if (!version) return;

    // Get historical demons list
    const historicalDemons = typeof version.demons === 'function' ? version.demons() : version.demons;

    // Create a visual indicator that we're viewing historical data
    const header = document.querySelector('.header-content h1');
    const originalTitle = header.innerHTML;
    header.innerHTML = `
        <span class="title-derpy">DERPY</span>
        <span class="title-demon">INSANE DEMON LIST</span>
        <div class="historical-indicator">🕰️ Viewing: ${version.title}</div>
    `;

    // Add historical indicator styles
    const style = document.createElement('style');
    style.id = 'historical-styles';
    style.textContent = `
        .historical-indicator {
            font-size: 14px;
            color: #673AB7;
            font-weight: 600;
            margin-top: 10px;
            padding: 8px 16px;
            background: rgba(103, 58, 183, 0.1);
            border-radius: 20px;
            display: inline-block;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .historical-top-5 {
            margin-top: 10px;
            padding-left: 20px;
            font-size: 14px;
        }
        .historical-top-5 li {
            margin: 5px 0;
            color: #673AB7;
        }
    `;
    document.head.appendChild(style);

    // Replace current demons with historical version
    window.currentHistoricalDemons = historicalDemons;
    renderDemons(historicalDemons);

    // Add restore button
    const restoreBtn = document.createElement('button');
    restoreBtn.textContent = '🔄 Return to Current List';
    restoreBtn.className = 'time-travel-btn';
    restoreBtn.style.cssText = 'position: fixed; top: 100px; right: 20px; z-index: 1001; max-width: 200px;';
    restoreBtn.addEventListener('click', () => {
        header.innerHTML = originalTitle;
        const historicalStyles = document.getElementById('historical-styles');
        if (historicalStyles) {
            document.head.removeChild(historicalStyles);
        }
        document.body.removeChild(restoreBtn);
        window.currentHistoricalDemons = null;
        renderDemons();
    });
    document.body.appendChild(restoreBtn);
}

function displayComparison(selectedDate) {
    const selectedVersion = historicalVersions[selectedDate];
    const currentVersion = historicalVersions['2025-10-05'];
    
    // Get demon lists
    const selectedDemons = typeof selectedVersion.demons === 'function' ? selectedVersion.demons() : selectedVersion.demons;
    const currentDemons = typeof currentVersion.demons === 'function' ? currentVersion.demons() : currentVersion.demons;
    
    document.getElementById('selectedDateTitle').textContent = selectedVersion.title;
    
    // Generate comparison data
    const positionChanges = [];
    const newAdditions = [];
    const removedDemons = [];
    
    // Find position changes
    selectedDemons.forEach((demon, index) => {
        const currentIndex = currentDemons.findIndex(d => d.name === demon.name);
        if (currentIndex !== -1 && currentIndex !== index) {
            const change = index - currentIndex;
            positionChanges.push({
                name: demon.name,
                oldPos: index + 1,
                newPos: currentIndex + 1,
                change: change
            });
        }
    });

    // Find new additions (in current but not in selected)
    currentDemons.forEach((demon, index) => {
        if (!selectedDemons.find(d => d.name === demon.name)) {
            newAdditions.push({
                name: demon.name,
                position: index + 1
            });
        }
    });

    // Find removed demons (in selected but not in current)
    selectedDemons.forEach(demon => {
        if (!currentDemons.find(d => d.name === demon.name)) {
            removedDemons.push({
                name: demon.name,
                reason: 'Difficulty reassessed'
            });
        }
    });

    // Update comparison display
    updateComparisonSection('positionChanges', positionChanges);
    updateComparisonSection('newAdditions', newAdditions);
    updateComparisonSection('removedDemons', removedDemons);
}

function updateComparisonSection(sectionId, data) {
    const section = document.getElementById(sectionId);
    section.innerHTML = '';

    if (sectionId === 'positionChanges') {
        data.slice(0, 10).forEach(item => { // Show top 10 changes
            const div = document.createElement('div');
            div.className = `change-item ${item.change > 0 ? 'moved-down' : 'moved-up'}`;
            div.innerHTML = `
                <span class="demon-name">${item.name}</span>
                <span class="change-info">#${item.oldPos} → #${item.newPos} <span class="change-type">${item.change > 0 ? '-' + item.change : '+' + Math.abs(item.change)}</span></span>
            `;
            section.appendChild(div);
        });
    } else if (sectionId === 'newAdditions') {
        data.slice(0, 10).forEach(item => {
            const div = document.createElement('div');
            div.className = 'addition-item';
            div.innerHTML = `
                <span class="demon-name">${item.name}</span>
                <span class="demon-position">#${item.position}</span>
            `;
            section.appendChild(div);
        });
    } else if (sectionId === 'removedDemons') {
        data.forEach(item => {
            const div = document.createElement('div');
            div.className = 'removal-item';
            div.innerHTML = `
                <span class="demon-name">${item.name}</span>
                <span class="removal-reason">${item.reason}</span>
            `;
            section.appendChild(div);
        });
    }

    if (data.length === 0) {
        section.innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">No changes in this category</p>';
    }
}

// Live Data Tracker System
class InsaneDemonListTracker {
    constructor() {
        this.apiEndpoint = 'https://insanedemonlist.com/api'; // Hypothetical API endpoint
        this.lastUpdate = localStorage.getItem('lastDataUpdate') || null;
        this.updateInterval = 30 * 60 * 1000; // 30 minutes
        this.isTracking = false;
        this.updateCallbacks = [];
    }

    // Initialize the live tracker
    initialize() {
        console.log('🔄 Initializing Insane Demon List Tracker...');
        this.createTrackerUI();
        this.checkForUpdates();
        this.startPeriodicUpdates();
    }

    // Create tracker UI in the header
    createTrackerUI() {
        const header = document.querySelector('.header');
        const trackerDiv = document.createElement('div');
        trackerDiv.className = 'live-tracker';
        trackerDiv.innerHTML = `
            <div class="tracker-status">
                <span class="status-dot" id="trackerDot"></span>
                <span id="trackerStatus">Checking for updates...</span>
            </div>
            <div class="last-update" id="lastUpdateTime" style="display: none;">
                Last update: ${this.lastUpdate ? new Date(parseInt(this.lastUpdate)).toLocaleString() : 'Never'}
            </div>
        `;
        header.appendChild(trackerDiv);

        // Add click listener to show/hide details
        trackerDiv.addEventListener('click', () => {
            this.toggleTrackerDetails();
        });
    }

    // Start periodic update checking
    startPeriodicUpdates() {
        if (this.isTracking) return;
        
        this.isTracking = true;
        this.updateTimer = setInterval(() => {
            this.checkForUpdates();
        }, this.updateInterval);

        console.log('📡 Live tracker started - checking every 30 minutes');
    }

    // Stop periodic updates
    stopPeriodicUpdates() {
        if (this.updateTimer) {
            clearInterval(this.updateTimer);
            this.isTracking = false;
            console.log('⏹️ Live tracker stopped');
        }
    }

    // Check for updates from insanedemonlist.com
    async checkForUpdates() {
        this.updateStatus('checking', 'Checking for updates...');
        
        try {
            // Since we can't directly access insanedemonlist.com's API (CORS restrictions),
            // we'll simulate the update checking process and provide manual update functionality
            const response = await this.simulateAPICall();
            
            if (response.hasUpdates) {
                this.updateStatus('updates-available', 'Updates available!');
                this.notifyUpdatesAvailable(response.changes);
            } else {
                this.updateStatus('up-to-date', 'Up to date');
                this.updateLastUpdateTime();
            }
        } catch (error) {
            console.error('Update check failed:', error);
            this.updateStatus('error', 'Update check failed');
        }
    }

    // Simulate API call (replace with real API when available)
    async simulateAPICall() {
        await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate network delay
        
        // For now, return no updates. In a real implementation, this would:
        // 1. Fetch data from insanedemonlist.com API
        // 2. Compare with current data
        // 3. Return detected changes
        return {
            hasUpdates: false,
            changes: {
                newDemons: [],
                positionChanges: [],
                removedDemons: []
            }
        };
    }

    // Toggle tracker details visibility
    toggleTrackerDetails() {
        const lastUpdateElement = document.getElementById('lastUpdateTime');
        const isVisible = lastUpdateElement.style.display !== 'none';
        
        if (isVisible) {
            lastUpdateElement.style.display = 'none';
            // Make pill smaller when collapsed
            document.querySelector('.live-tracker').style.borderRadius = '25px';
        } else {
            lastUpdateElement.style.display = 'block';
            // Make pill slightly larger when expanded
            document.querySelector('.live-tracker').style.borderRadius = '15px';
            // Also force an update check when expanded
            this.forceUpdate();
        }
    }

    // Force an immediate update check
    async forceUpdate() {
        console.log('🔄 Force update requested');
        await this.checkForUpdates();
    }

    // Update tracker status
    updateStatus(status, message) {
        const dot = document.getElementById('trackerDot');
        const statusText = document.getElementById('trackerStatus');
        
        if (dot && statusText) {
            dot.className = `status-dot ${status}`;
            statusText.textContent = message;
        }
    }

    // Update last update time
    updateLastUpdateTime() {
        const now = Date.now().toString();
        localStorage.setItem('lastDataUpdate', now);
        this.lastUpdate = now;
        
        const lastUpdateElement = document.getElementById('lastUpdateTime');
        if (lastUpdateElement) {
            lastUpdateElement.textContent = `Last update: ${new Date(parseInt(now)).toLocaleString()}`;
        }
    }

    // Notify when updates are available
    notifyUpdatesAvailable(changes) {
        const notification = document.createElement('div');
        notification.className = 'update-notification';
        notification.innerHTML = `
            <div class="notification-content">
                <h3>🚀 List Updates Available!</h3>
                <p>New changes detected from insanedemonlist.com</p>
                <div class="notification-actions">
                    <button onclick="liveTracker.applyUpdates()">Apply Updates</button>
                    <button onclick="this.parentElement.parentElement.parentElement.remove()">Dismiss</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove notification after 30 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 30000);
    }

    // Apply updates to the demon list
    applyUpdates() {
        // In a real implementation, this would:
        // 1. Backup current data
        // 2. Apply new changes
        // 3. Update the display
        // 4. Show changelog
        
        console.log('📝 Applying updates...');
        alert('Update system ready! This will sync with insanedemonlist.com when their API is available.');
        this.updateLastUpdateTime();
        this.updateStatus('up-to-date', 'Up to date');
        
        // Remove notification
        const notification = document.querySelector('.update-notification');
        if (notification) {
            notification.remove();
        }
    }

    // Add callback for when updates occur
    onUpdate(callback) {
        this.updateCallbacks.push(callback);
    }

    // Get tracker statistics
    getStats() {
        return {
            isTracking: this.isTracking,
            lastUpdate: this.lastUpdate,
            updateInterval: this.updateInterval,
            status: document.getElementById('trackerStatus')?.textContent || 'Unknown'
        };
    }
}

// Initialize live tracker
const liveTracker = new InsaneDemonListTracker();

// Admin functions for monitoring the tracker (accessible via browser console)
window.trackerAdmin = {
    getStats: () => liveTracker.getStats(),
    forceUpdate: () => liveTracker.forceUpdate(),
    startTracking: () => liveTracker.startPeriodicUpdates(),
    stopTracking: () => liveTracker.stopPeriodicUpdates(),
    setUpdateInterval: (minutes) => {
        liveTracker.updateInterval = minutes * 60 * 1000;
        console.log(`✅ Update interval set to ${minutes} minutes`);
    },
    help: () => {
        console.log(`
🔧 Tracker Admin Commands:
- trackerAdmin.getStats() - Get current tracker status
- trackerAdmin.forceUpdate() - Force immediate update check
- trackerAdmin.startTracking() - Start periodic updates
- trackerAdmin.stopTracking() - Stop periodic updates
- trackerAdmin.setUpdateInterval(minutes) - Change update frequency
- trackerAdmin.help() - Show this help
        `);
    }
};

// Development helper
console.log(`
🚀 DerpyIDL Live Tracker System Ready!
📡 Monitoring insanedemonlist.com for changes
⚙️ Type 'trackerAdmin.help()' in console for admin commands
`);

// Info Modal System
function initializeInfoModal() {
    const infoBtn = document.getElementById('infoBtn');
    const infoModal = document.getElementById('infoModal');
    const closeInfoModal = document.getElementById('closeInfoModal');

    // Open info modal
    infoBtn.addEventListener('click', () => {
        infoModal.style.display = 'block';
        document.body.style.overflow = 'hidden'; // Prevent background scroll
    });

    // Close info modal
    closeInfoModal.addEventListener('click', () => {
        infoModal.style.display = 'none';
        document.body.style.overflow = 'auto'; // Restore scroll
    });

    // Close modal when clicking outside
    infoModal.addEventListener('click', (e) => {
        if (e.target === infoModal) {
            infoModal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }
    });

    // Close modal with Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && infoModal.style.display === 'block') {
            infoModal.style.display = 'none';
            document.body.style.overflow = 'auto';
        }
    });

    console.log('ℹ️ Info modal system initialized');
}
